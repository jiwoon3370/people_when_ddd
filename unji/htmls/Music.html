<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MST ê¸°ë°˜ í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ ìƒì„±ê¸° (ì‹œê°í™”)</title>
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        body { font-family: 'Arial', sans-serif; line-height: 1.6; margin: 20px; background-color: #f4f4f9; color: #333; }
        .container { max-width: 1000px; margin: auto; background: white; padding: 30px; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        h1 { color: #8A2BE2; text-align: center; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        h2 { color: #5B3A9B; margin-top: 25px; }
        .input-area { margin-bottom: 30px; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
        input[type="text"], input[type="number"] { padding: 8px; margin: 5px 0; border: 1px solid #ccc; border-radius: 4px; width: 120px; }
        button { background-color: #8A2BE2; color: white; padding: 10px 15px; border: none; border-radius: 5px; cursor: pointer; font-size: 1em; margin-right: 10px; }
        button:hover { background-color: #6A1AA5; }
        #network { width: 100%; height: 500px; border: 1px solid #ccc; margin-top: 20px; }
        #edgeList { list-style: none; padding: 0; max-height: 150px; overflow-y: auto; }
        #edgeList li { background: #e6e6fa; margin: 5px 0; padding: 5px; border-radius: 4px; }
        .result-area { margin-top: 20px; }
        .cluster-A { color: #e74c3c; font-weight: bold; }
        .cluster-B { color: #2ecc71; font-weight: bold; }
        .cluster-C { color: #3498db; font-weight: bold; }
    </style>
</head>
<body>

<div class="container">
    <h1>ğŸ¶ MST ê¸°ë°˜ í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ ìƒì„±ê¸° (ì‹œê°í™”)</h1>
    
    <div class="input-area">
        <h2>1. ë°ì´í„° ì…ë ¥ (ë…¸ë˜ ë° ë¹„ìœ ì‚¬ì„±)</h2>
        <div>
            <input type="text" id="nodeA" placeholder="ë…¸ë˜ A ì´ë¦„">
            <input type="text" id="nodeB" placeholder="ë…¸ë˜ B ì´ë¦„">
            <input type="number" id="weight" placeholder="ë¹„ìœ ì‚¬ì„± (ê±°ë¦¬)" min="0">
            <button onclick="addEdge()">ê°„ì„  ì¶”ê°€</button>
            <button onclick="resetData()" style="background-color: #e74c3c;">ì´ˆê¸°í™”</button>
            <button onclick="loadSampleData()" style="background-color: #3498db;">ìƒ˜í”Œ ë°ì´í„° ë¡œë“œ</button>
        </div>
        
        <div style="display: flex; justify-content: space-between;">
            <div>
                <h3>í˜„ì¬ ê°„ì„  ëª©ë¡</h3>
                <ul id="edgeList"></ul>
            </div>
            <div>
                <button onclick="startClustering()" id="startButton" style="margin-top: 30px;">
                    âš™ï¸ êµ¬ì¶• ì‹œì‘ & ì‹œê°í™”!
                </button>
                <p id="statusMessage" style="margin-top: 15px; font-weight: bold;"></p>
            </div>
        </div>
    </div>

    <h2>2. MST êµ¬ì¶• ë° í´ëŸ¬ìŠ¤í„° ì‹œê°í™”</h2>
    <p>ê·¸ë˜í”„ì˜ ìƒ‰ê¹”ì€ í´ëŸ¬ìŠ¤í„°(í”Œë ˆì´ë¦¬ìŠ¤íŠ¸)ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤.</p>
    <div id="network"></div>

    <div class="result-area">
        <h3>ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ (MST) ì •ë³´</h3>
        <p id="mstInfo">ì—¬ê¸°ì— MSTì˜ ì´ ê°€ì¤‘ì¹˜ ì •ë³´ê°€ í‘œì‹œë©ë‹ˆë‹¤.</p>
        
        <h3>ìƒì„±ëœ ìœ ì‚¬ í”Œë ˆì´ë¦¬ìŠ¤íŠ¸</h3>
        <ul id="playlistResult"></ul>
    </div>
</div>

<script>
    // --- Global Variables and Setup ---
    let edges = [];
    let nodes = new Set();
    const networkElement = document.getElementById('network');
    let visNetwork = null;
    const clusterColors = ['#e74c3c', '#2ecc71', '#3498db', '#f39c12', '#9b59b6'];

    // --- Graph Rendering Setup (Vis.js) ---
    function drawGraph(graphNodes, graphEdges) {
        const data = {
            nodes: new vis.DataSet(graphNodes),
            edges: new vis.DataSet(graphEdges)
        };
        const options = {
            nodes: {
                shape: 'dot',
                size: 20,
                font: { size: 14, color: '#333' },
                borderWidth: 2
            },
            edges: {
                width: 2,
                color: { inherit: 'from' },
                font: { align: 'top' }
            },
            physics: { enabled: true }
        };
        visNetwork = new vis.Network(networkElement, data, options);
    }
    
    // --- Data Management Functions ---
    function addEdge() {
        const nodeA = document.getElementById('nodeA').value.trim();
        const nodeB = document.getElementById('nodeB').value.trim();
        const weight = parseFloat(document.getElementById('weight').value);

        if (!nodeA || !nodeB || isNaN(weight) || weight < 0 || nodeA === nodeB) {
            alert('ìœ íš¨í•œ ë…¸ë“œ ì´ë¦„ê³¼ ì–‘ìˆ˜ ê°€ì¤‘ì¹˜ë¥¼ ì…ë ¥í•˜ì„¸ìš”.');
            return;
        }

        edges.push({ u: nodeA, v: nodeB, w: weight });
        nodes.add(nodeA);
        nodes.add(nodeB);
        
        // Clear inputs
        document.getElementById('nodeA').value = '';
        document.getElementById('nodeB').value = '';
        document.getElementById('weight').value = '';

        renderEdges();
        updateInitialGraph();
    }
    
    function loadSampleData() {
        resetData();
        const sampleEdges = [
            { u: 'Rock A', v: 'Rock B', w: 3 },
            { u: 'Rock A', v: 'Pop C', w: 10 },
            { u: 'Rock B', v: 'Pop D', w: 15 },
            { u: 'Pop C', v: 'Pop D', w: 4 },
            { u: 'Pop D', v: 'Jazz E', w: 18 }, // ì´ ê°„ì„ ì´ í´ëŸ¬ìŠ¤í„° ê²½ê³„ê°€ ë  ê°€ëŠ¥ì„± ë†’ìŒ
            { u: 'Pop C', v: 'Jazz E', w: 8 },
            { u: 'Rock A', v: 'Jazz E', w: 20 },
            { u: 'Jazz E', v: 'Jazz F', w: 2 },
        ];
        sampleEdges.forEach(e => {
            edges.push(e);
            nodes.add(e.u);
            nodes.add(e.v);
        });
        renderEdges();
        updateInitialGraph();
    }

    function resetData() {
        edges = [];
        nodes = new Set();
        document.getElementById('edgeList').innerHTML = '';
        document.getElementById('playlistResult').innerHTML = '';
        document.getElementById('mstInfo').textContent = 'ì—¬ê¸°ì— MSTì˜ ì´ ê°€ì¤‘ì¹˜ ì •ë³´ê°€ í‘œì‹œë©ë‹ˆë‹¤.';
        document.getElementById('statusMessage').textContent = '';
        drawGraph([], []); // Clear graph visualization
    }

    function renderEdges() {
        const edgeListElement = document.getElementById('edgeList');
        edgeListElement.innerHTML = '';
        edges.forEach(edge => {
            const li = document.createElement('li');
            li.textContent = `${edge.u} â†” ${edge.v} (W: ${edge.w})`;
            edgeListElement.appendChild(li);
        });
    }

    function updateInitialGraph() {
        const graphNodes = Array.from(nodes).map(node => ({ id: node, label: node, color: '#9DD' }));
        const graphEdges = edges.map((edge, index) => ({ 
            id: index, 
            from: edge.u, 
            to: edge.v, 
            label: String(edge.w), 
            color: { color: '#888' }, 
            dashes: true 
        }));
        drawGraph(graphNodes, graphEdges);
    }
    
    // --- MST & Clustering Logic (Kruskal & Union-Find) ---
    let parent = {};
    const find = (i) => {
        if (parent[i] === i) return i;
        return parent[i] = find(parent[i]);
    };
    const union = (i, j) => {
        const rootI = find(i);
        const rootJ = find(j);
        if (rootI !== rootJ) {
            parent[rootI] = rootJ;
            return true;
        }
        return false;
    };
    
    function startClustering() {
        if (nodes.size < 2 || edges.length === 0) {
            alert('ìµœì†Œ 2ê°œ ì´ìƒì˜ ë…¸ë“œì™€ ê°„ì„ ì„ ì…ë ¥í•´ì•¼ í•©ë‹ˆë‹¤.');
            return;
        }

        document.getElementById('statusMessage').textContent = 'MST êµ¬ì¶• ë° í´ëŸ¬ìŠ¤í„°ë§ ì¤‘...';
        
        // 1. Kruskal's Algorithm
        parent = {};
        nodes.forEach(node => parent[node] = node);
        const sortedEdges = [...edges].sort((a, b) => a.w - b.w);
        
        let mstEdges = [];
        let totalWeight = 0;

        for (const edge of sortedEdges) {
            if (union(edge.u, edge.v)) {
                mstEdges.push(edge);
                totalWeight += edge.w;
            }
        }
        
        if (mstEdges.length !== nodes.size - 1 && nodes.size > 1) {
             document.getElementById('statusMessage').textContent = 'ğŸš¨ ì˜¤ë¥˜: ê·¸ë˜í”„ê°€ ì™„ì „íˆ ì—°ê²°ë˜ì–´ ìˆì§€ ì•Šì•„ MSTë¥¼ ì™„ì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.';
             return;
        }

        document.getElementById('mstInfo').textContent = `ì´ ìµœì†Œ ë¹„ìœ ì‚¬ì„± (MST ê°€ì¤‘ì¹˜ í•©): ${totalWeight.toFixed(2)}`;
        
        // 2. í´ëŸ¬ìŠ¤í„°ë§ (ê°€ì¥ ë¹„ì‹¼ ê°„ì„  K-1ê°œ ì œê±°)
        const K_CLUSTERS = 3; // ëª©í‘œ í´ëŸ¬ìŠ¤í„° ê°œìˆ˜ (ì˜ˆì‹œë¡œ 3ê°œ)
        const K_minus_1 = Math.min(mstEdges.length - 1, K_CLUSTERS - 1); 
        
        // MST ê°„ì„ ì„ ê°€ì¤‘ì¹˜ ë‚´ë¦¼ì°¨ìˆœìœ¼ë¡œ ì •ë ¬
        const mstSortedDesc = [...mstEdges].sort((a, b) => b.w - a.w);
        
        const removedEdges = mstSortedDesc.slice(0, K_minus_1);
        const finalMstEdges = mstSortedDesc.slice(K_minus_1);

        // 3. Union-Find ì¬ì‹¤í–‰ (í´ëŸ¬ìŠ¤í„° í˜•ì„±)
        parent = {};
        nodes.forEach(node => parent[node] = node);

        for (const edge of finalMstEdges) {
            union(edge.u, edge.v);
        }

        // 4. í´ëŸ¬ìŠ¤í„° ê·¸ë£¹í•‘
        const clusters = {};
        nodes.forEach(node => {
            const root = find(node);
            if (!clusters[root]) clusters[root] = [];
            clusters[root].push(node);
        });

        // 5. ì‹œê°í™” ì—…ë°ì´íŠ¸
        visualizeResult(mstEdges, removedEdges, clusters);
        
        // 6. í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ ê²°ê³¼ ì¶œë ¥
        displayPlaylistResult(clusters);
        document.getElementById('statusMessage').textContent = 'âœ… êµ¬ì¶• ì™„ë£Œ! ê·¸ë˜í”„ ë° í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ë¥¼ í™•ì¸í•˜ì„¸ìš”.';
    }

    // --- Result Visualization Functions ---
    function visualizeResult(mstEdges, removedEdges, clusters) {
        const clusterMap = {};
        let clusterIndex = 0;
        
        // ë…¸ë“œ ìƒ‰ìƒ ë§¤í•‘
        for (const root in clusters) {
            clusters[root].forEach(node => {
                clusterMap[node] = clusterColors[clusterIndex % clusterColors.length];
            });
            clusterIndex++;
        }
        
        const graphNodes = Array.from(nodes).map(node => ({ 
            id: node, 
            label: node, 
            color: clusterMap[node] 
        }));

        const graphEdges = edges.map((edge, index) => {
            // MST í¬í•¨ ì—¬ë¶€
            const isMST = mstEdges.some(e => (e.u === edge.u && e.v === edge.v && e.w === edge.w) || (e.u === edge.v && e.v === edge.u && e.w === edge.w));
            // ì œê±°ëœ ê°„ì„  ì—¬ë¶€ (í´ëŸ¬ìŠ¤í„° ê²½ê³„)
            const isRemoved = removedEdges.some(r => (r.u === edge.u && r.v === edge.v && r.w === edge.w) || (r.u === edge.v && r.v === edge.u && r.w === edge.w));
            
            let color = '#AAA'; // ê¸°ë³¸ ìƒ‰ìƒ (MST ì•„ë‹˜)
            let width = 1;
            let dashes = true;

            if (isMST && !isRemoved) {
                // MSTì— í¬í•¨ë˜ê³ , ì œê±°ë˜ì§€ ì•Šì€ ê°„ì„  (í´ëŸ¬ìŠ¤í„° ë‚´ë¶€ ì—°ê²°)
                color = clusterMap[edge.u]; // í´ëŸ¬ìŠ¤í„° ìƒ‰ìƒìœ¼ë¡œ í‘œì‹œ
                width = 4;
                dashes = false;
            } else if (isRemoved) {
                // ì œê±°ëœ ê°„ì„  (í´ëŸ¬ìŠ¤í„° ê²½ê³„)
                color = '#FF0000'; 
                width = 2;
                dashes = true;
            }
            // ê·¸ ì™¸ MSTì— í¬í•¨ë˜ì§€ ì•Šì€ ê°„ì„ ì€ ê¸°ë³¸ íšŒìƒ‰ ì ì„ 

            return { 
                id: index, 
                from: edge.u, 
                to: edge.v, 
                label: String(edge.w), 
                color: { color: color }, 
                width: width,
                dashes: dashes
            };
        });
        
        drawGraph(graphNodes, graphEdges);
    }

    function displayPlaylistResult(clusters) {
        const playlistResultElement = document.getElementById('playlistResult');
        playlistResultElement.innerHTML = '';
        let clusterIndex = 0;
        const clusterClasses = ['cluster-A', 'cluster-B', 'cluster-C', 'cluster-D', 'cluster-E'];
        
        for (const root in clusters) {
            const className = clusterClasses[clusterIndex % clusterClasses.length];
            const colorCode = clusterColors[clusterIndex % clusterColors.length];
            
            const li = document.createElement('li');
            li.innerHTML = `<strong style="color:${colorCode}">[í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ ${clusterIndex + 1}] (${clusters[root].length}ê³¡):</strong> ${clusters[root].join(', ')}`;
            playlistResultElement.appendChild(li);
            clusterIndex++;
        }
    }
    
    // Initial graph drawing
    document.addEventListener('DOMContentLoaded', () => {
        drawGraph([], []);
    });
</script>

</body>
</html>
